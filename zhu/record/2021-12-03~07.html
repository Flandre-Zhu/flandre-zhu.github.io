<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="2021.12.3~2021.12.712.3~12.5 在号爸训练 12.6~12.7 相当颓废。只完成了号爸里面留下来的题。因此我把这几天也并起来写。 做题topcoder 14519114514 （幻视） 真tm傻逼，我C，我会做了，但是实现很jb复杂，网上还找不到题解。 还好在tc的客户端中找到了 xudyh 的代码。这玩意还不支持复制，我手动敲了一遍。ctmd topcoder。 做法比">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://flandre-zhu.github.io/zhu/record/2021-12-03~07.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="2021.12.3~2021.12.712.3~12.5 在号爸训练 12.6~12.7 相当颓废。只完成了号爸里面留下来的题。因此我把这几天也并起来写。 做题topcoder 14519114514 （幻视） 真tm傻逼，我C，我会做了，但是实现很jb复杂，网上还找不到题解。 还好在tc的客户端中找到了 xudyh 的代码。这玩意还不支持复制，我手动敲了一遍。ctmd topcoder。 做法比">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-02-20T06:09:42.664Z">
<meta property="article:modified_time" content="2021-12-10T01:35:14.000Z">
<meta property="article:author" content="Flandre Zhu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://flandre-zhu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="page-" class="h-entry article article-type-page" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/zhu/record/2021-12-03~07.html" class="article-date">
  <time class="dt-published" datetime="2022-02-20T06:09:42.664Z" itemprop="datePublished">2022-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="2021-12-3-2021-12-7"><a href="#2021-12-3-2021-12-7" class="headerlink" title="2021.12.3~2021.12.7"></a>2021.12.3~2021.12.7</h1><p>12.3~12.5 在号爸训练</p>
<p>12.6~12.7 相当颓废。只完成了号爸里面留下来的题。因此我把这几天也并起来写。</p>
<h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><h3 id="topcoder-14519"><a href="#topcoder-14519" class="headerlink" title="topcoder 14519"></a>topcoder 14519</h3><p>114514 （幻视）</p>
<p>真tm傻逼，我C，我会做了，但是实现很jb复杂，网上还找不到题解。</p>
<p>还好在tc的客户端中找到了 xudyh 的代码。这玩意还不支持复制，我手动敲了一遍。ctmd topcoder。</p>
<p>做法比较简单，和hyh激烈讨♂论一番后不难得到。</p>
<p>首先处理出每个 $p(i)$ 最强的限制，就是它最深可以确定在谁的子树里。就是所有涉及到 $i$ 的限制中，最深的LCA，设这个最深的限制点为 $sub(i)$。把 $i$ 挂在 $sub(i)$ 上。开 $n$ 张图，设为 $G<em>1…G_n$。 如果 $i,j$ 都挂在 $sub(i)$ 上，且要求 $LCA(p(i),p(j))=sub(i)$，则在 $G</em>{sub(i)}$ 上，对 $i,j$ 进行一个连边。连边表示这两个点不能同属左/右子树。</p>
<p>然后从下往上做。考虑到下面的子树填好之后，对于上面的点来说，下面空了一堆空，但都是 “左子树的空” 和 “右子树的空”，只关心是左是右，而具体在哪，我们完全不用在意。因此从下往上填就是对的。</p>
<p>考虑当前在 $u$ 点，已知左右有 $L,R$ 个空的时候，如何填。枚举谁做根，并把图上这个点删去。那么要求剩下的图是个二分图。做完二分图染色之后，我们还需要一个类似背包的dp，来判断是否能分成两半，一半不超过 $L$ 个，一半不超过 $R$ 个。写个 $O(n^3)$ 的 dp 即可。状态与转移sb，略。记录一下解。</p>
<p>记录完解之后，我们把左右的空的位置也记一下。把我们的划分好的方案，依次放到 $L,R$ 中去。</p>
<p><a target="_blank" rel="noopener" href="https://pastebin.ubuntu.com/p/kWQVj5vrRF/">参考实现</a></p>
<h3 id="Codeforces-79D"><a href="#Codeforces-79D" class="headerlink" title="Codeforces 79D"></a>Codeforces 79D</h3><blockquote>
<p>hb: 区间操作不好做，转化为差分数组的两点操作。</p>
</blockquote>
<p>根据这个常见的考虑，我们对异或的差分数组进行两点操作。两点操作，有一个特殊情况。如果其中一个是$1$，另一个是 $0$，则我们相当于交换了 $0,1$ 的位置。又或者，把 $1$ “移动” 了过来。如果两个都是$1$呢？那我们相当于把其中一个$1$移动过去，再和原来那个$1$异或，因此得到的是两个 $0$。</p>
<p>如果我们连续的进行两点操作，我们发现，它可以合并。例如我对 $(a,b),(b,c),(c,d)$ 这些位置做两点操作，实际上就等价于对 $(a,d)$ 做了操作。我们发现，“移动”，“合并”，非常像一个路径上的走路。没错，我们把一个两点操作，就看成连边，相当于有一堆 $1$ 在图上走路。</p>
<p>那么怎么样才能抵消呢？如果一个$1$“走”到了另一个 $1$，这俩都会抵消，变成 $0$。相当于我们要让给定位置的这些 $1$ 两两匹配。</p>
<blockquote>
<p>注意，区间 $[i,n]$ 这样，其实只能转化成 “单点操作”。如果某个 $1$ 和这个单点连通，那它可以直接被消去。但这个技能我们只能用最多一次，枚举即可。</p>
</blockquote>
<p>然后就容易写出一个 $O(2^{2k})$ 的状压dp。$2k$ 是因为，原来有 $k$ 个 $1$，一个 $1$ 取差分会变成两个 $1$，因此最多可达 $2k$ 个 $1$。</p>
<h3 id="Codeforces-79E"><a href="#Codeforces-79E" class="headerlink" title="Codeforces 79E"></a>Codeforces 79E</h3><p>首先，对于一大块的sensor，我们显然只关注四角上的。</p>
<blockquote>
<p>hyh: 对于“字典序最小”，我们考虑按位确定可行性</p>
</blockquote>
<p>那现在就变成，如何确定一个任意位置开始，是否能够通关。每次尝试往右，如果往右不行，再往上。这样一定得到字典序最小的。</p>
<p>那现在就变成了check。注意，check的时候，不需要注意字典序。</p>
<p>4个边角，把平面分成了9个部分。如图。</p>
<p>如果在红色的区域，即最左下角和最右上角，则随便走都是ok的。</p>
<p>如果在蓝色的区域，显然我们会往右走。首先我们显然不会往下走。然后往右走会使得多数sensor距离变小。反之，如果往上走，就会把距离提高，提高完之后要保持在一个高水平继续往右 （注意到我们一定免不了一些往右往上的移动），会更劣。</p>
<p>同理，在绿色区域，咱一定选择往上走。这些可以用一个简单的递归 （大约不超过3层）来方便的实现。</p>
<p>关键问题是，中间那一块白色区域，我们怎么走。这正是本题的精髓。</p>
<blockquote>
<p>hyh: 你先搞几个显然对的结论，组合在一起，你就会做了。</p>
</blockquote>
<p>根据何老师的指示，我们搞几个显然对的结论。</p>
<ol>
<li>无论怎么走，左下，右上两个sensor的减少的值恒定。<blockquote>
<p>解决不了问题，就解决造成问题的人。尽管没解决问题，但我们解决了一半的人！nice。</p>
</blockquote>
</li>
<li>一路往上再往右，到左上距离和最小，到右下距离和最大；反之，一路往右再往上，到右下距离和最小，到左上距离和最大。</li>
<li>如果我们有一条路径，到左上，右下的距离和是 $(x,y)$，则 $(x+2k,y-2k),k\in \Z$ 都是可以做到的。<blockquote>
<p>这个就调整一下，找到路径上的一个角，把它折下来即可。</p>
</blockquote>
</li>
<li>对于一条路径，它到左上，右下的距离和是一定的。 （显然）</li>
</ol>
<p>综上，我们设到左上，右下距离和分别是 $x,y$，需满足：</p>
<ol>
<li>$x\in[L_1,R_1],x\equiv L_1 \pmod 2$</li>
<li>$y\in[L_2,R_2],y\equiv L_2 \pmod 2$</li>
<li>$x+y=s$，$s$ 为某个定值。<br>容易发现这个是充分必要的。接下来，需判断是否存在一组 $x,y$ 使得： $x\le A,y\le B$，$A,B$ 为某个定值。</li>
</ol>
<p>这个很容易，瞎jb讨论即可。因此本题就做完了，复杂度 $O(n)$。</p>
<p><a target="_blank" rel="noopener" href="https://codeforces.ml/contest/79/submission/137944762">参考实现</a></p>
<blockquote>
<p>CF真是比tc阳间多了！</p>
</blockquote>
<h3 id="Codeforces-1251F"><a href="#Codeforces-1251F" class="headerlink" title="Codeforces 1251F"></a>Codeforces 1251F</h3><p>首先红色的 <del>击剑</del> 栅栏只有 $O(1)$ 个，暴力枚举即可。接下来考虑白色栅栏。</p>
<p>对于一个白色栅栏，如果它只出现一次，那么我们可以选择把它放左/右，两种方案。</p>
<p>如果它出现了很多次，但我们只选一个，同上；否则，我们只能选两个 （注意到，选三个就不能满足 <strong>严格</strong> 单调了），且方案仅有一种。</p>
<p>你可以尝试推式子。然后发现不行，因为你不会做。</p>
<p>接下来考虑询问lzj。lzj会告诉你，用GF做。出现一次，GF贡献就是 $1+2x$，否则贡献 $1+2x+x^2$，卷起来即可。要写个快速幂。</p>
<blockquote>
<p>zps傻逼，推了好久式子不会推还他妈推，推睡着了都</p>
</blockquote>
<h3 id="Codeforces-1528F"><a href="#Codeforces-1528F" class="headerlink" title="Codeforces 1528F"></a>Codeforces 1528F</h3><p>很精彩的题。</p>
<p>首先结论：一个 $a$ 合法，当且仅当排好序后第 $i$ 位 $\le i$。容易观察得到。</p>
<p>转化成一个模型：$n$ 个人上撤硕，第 $i$ 个人期望蹲在 $a_i$ 号坑。若这个坑有人，他会不断找下一个 （+1），直到这个坑没人。如果找到 $n$ 还有人，则这个人就挂了，证明 $a$ 不合法，否则 $a$ 合法。</p>
<blockquote>
<p>为什么 $a$ 合法？设 $i$ 蹲在了 $b_i$ 位置，则显然 $b_i$ 互不相同，且 $b_i\ge a_i$，即要求的排列。也可以证明这和我们观察的转化一致。</p>
</blockquote>
<p>这里不合法是当 “找到 $n$ 还不行” 的时候不合法。如果你是聪明的小伙子，你想要上撤硕，一定会从头开始找。</p>
<p>我们在末尾放一个传送门，把它传回开始位置。如果传送门被使用了一次以上，可知 $a$ 不合法。再转化，我们在末尾新建一个 $n+1$ 号坑，并把坑位排成环形。若 $n+1$ 号坑有人，证明不合法。</p>
<blockquote>
<p>新建 $n+1$ 号坑，是一个常见的技巧，据hyh,wjy所说。尽管我只知道这一题。</p>
</blockquote>
<p>发现这个模型的性质很好。因为最后只会剩下恰好一个坑没人。如果剩下的是 $n+1$ 就合法否则不合法。</p>
<p>我们发现，一个合法的方案，对所有 $a$ 进行一个循环的（即，$n+1$ 再 $+1$ 就变成 $1$） $+1,+2,+3…+k(k&lt;n+1)$，都会变成一个不合法的方案。因此，合法的方案和不合法的方案是 $1:n$ 对应的。如果这题只要求 $a$ 数量，答案是 $(n+1)^{n-1}$。</p>
<blockquote>
<p>注意，这里研究的 $a$ 权值上限由 $n$ 变成 $n+1$，也就是说我们认为的 “任选” 是 $(n+1)^n$ 种。</p>
</blockquote>
<p>我们还需要求伴随 $b$ 的数量。对于一个 $a$，$a$ 中某元素出现恰好 $x$ 次，则贡献 $x^k$ 的方案数，对于每种元素求和即可。</p>
<p>然后我们发现，刚才那个 $1$ 对 $n$ 的映射，不影响每种元素出现的次数，也就不影响 $b$ 的数量。</p>
<p>因此，得到重要结论：满足条件 $b$ 数量 = 任意 $b$ 数量 $\times \dfrac{1}{n+1}$。</p>
<p>转化为数任意 $b$ 的数量。考虑按照出现次数来确定。枚举元素 $x$，$n+1$ 种；枚举它出现多少次 $i$，求和：</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{n} i^k\times \binom{n}{i}\times n^{n-i}</script><p>其中 $n^{n-i}$ 是剩下选的方案数，由于不能为 $x$，只有 $n$ 种方案。然后枚举 $x$ 那里乘一个 $n+1$，但满足条件的只有其中的 $\dfrac{1}{n+1}$，这一乘一除恰好抵消，我们只考虑上面那个式子即可。</p>
<p>斯特林反演。</p>
<script type="math/tex; mode=display">
=\sum\limits_{i=1}^{n}\binom{n}{i} n^{n-i} \sum\limits_{j=1}^{k} {k\brace j}\binom{i}{j}j!\\
=\sum\limits_{j=1}^{k}\sum\limits_{i=j}^{n} {k\brace j}\binom{n}{i}\binom{i}{j}n^{n-i}j!\\
=\sum\limits_{j=1}^{k}\sum\limits_{i=j}^{n} {k\brace j}\binom{n}{j}j!\binom{n-j}{i-j}n^{n-i}\\
=\sum\limits_{j=1}^{k}{k\brace j}\binom{n}{j}j! \sum\limits_{i=j}^{n} \binom{n-j}{i-j}n^{n-i}\\</script><p>后面那一块经过一些变形，发现是个二项式定理的形式。因此转化为</p>
<script type="math/tex; mode=display">
=\sum\limits_{j=1}^{k}{k\brace j}\binom{n}{j}j!(n+1)^{n-j}\\</script><p>这个式子就是 $O(k)$ 的了。但是要计算斯特林数，使用 NTT 计算一行，复杂度 $O(k\log k)$。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://flandre-zhu.github.io/zhu/record/2021-12-03~07.html" data-id="ckzy4tl2d00199gunaghf620c" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    

  
    
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Flandre Zhu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>