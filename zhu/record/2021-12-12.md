# 2021.12.12

下午和家人过生日了。按道理明天才是我生日，但是我周一没有空，所以才今天过生日。

## 写题: CF1313E

这题从昨天晚上想到了今天，改了几个做法过去。

首先肯定是枚举 $s$ 中的断点 $p$，接下来我们需要在 $t_1$ 中寻找 $s[1,p]$，在 $t_2$ 中寻找 $s[p+1,n]$。

然后一个很直观的思路是，我们暴力维护匹配位置，然后数相交的区间数即可。

两个区间相交，设第一个区间为 $[l_1,r_1]$，第二个为 $[l_2,r_2]$，则一定满足 $l_1\le r_2$，否则不可能相交。

两个区间的长度和为 $n$，这是我们所保证的。容易发现，让 $r_2-l_1+1<n$ 的时候，一定会有交，否则一定不会有交。

> 怎么想到：考虑临界情况，刚好没交的时候，恰好一人一半，此时有 $r_2-l_1+1=n$。然后如果中间的空隙小，更加排不开两个区间，则一定会有交，因此是 $r_2-l_1+1<n$ 的时候区间有交。

那么如果我们能维护 $l_1,r_2$ 的集合 $P,Q$，那么用两个树状数组就可以维护出当前 $r_2-l_1+1<n$ 的数量了。仅支持加入/删除单个元素。就维护一下贡献，很好搞。

注意到 $l_1,r_2$ 没啥本质区别，可以reverse转换。因此考虑做 $l_1$，维护它的集合。

随着 $p$ 的增加，$s[1,p]$ 会不断往后面加一个字符。那么每次的集合都是上一次的子集。如果能够找到 **恰好** 需要删哪些位置，维护集合的均摊复杂度就是 $O(n)$ 的了。

> 在这里，我一开始还想了个SAM做法，非常的sb

某个位置 $i$ 需要在枚举到长度为 $p$ 时被删掉，那说明 $t_1[i,m]$ 与 $s$ 的 LCP 长度为 $p-1$。也就是说我们可以通过 LCP 长度来判断每次需要删哪些东西。

那就好做了，跑个exkmp （z函数），然后开一堆vector记一下就可以了。

![代码](https://codeforces.ml/contest/1313/submission/138827760)