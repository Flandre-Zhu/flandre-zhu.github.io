[toc]

# 2021-11-15

## 做题

泛做题。今天选的是CF div2的后面几题来做。目的是，让我勇于挑战难题，并尝试通过逐步递进法，慢慢接近正解。

今天颓废的比较多，也复习以前的算法，接下来就是做题环节。

AC数量：3

### CF1605E

限时1h，用时50min。

肯定要先考虑确定了 $b$ 之后咋做，这是显然的。

我观察出来，$b_1$ 的调整只能通过 $a_1$ 修改。搞完 $b_1$ 之后，$b_2$ 也只能通过 $a_2$ 修改。不断推下去即可。

修改一个位置后，可以暴力枚举倍数处理影响，这是 $O(n\ln n)$ 的。因此这样做一次的复杂度是 $O(n\ln n)$

这样不利于做动态的 $b_1$。因此，我们要试着写一个东西出来，来做这个。

我接下来就想着，大概是要抽象出来一个式子，关于 $b_1$。经过一番思考，我把上述递推过程变成了这样：

- 设 $f(i)$ 表示对 $i$ 以及其倍数的位置，加上了多少，可以是负的。
- 得到递推：$f(i)=b_i-(\sum\limits_{d|i,d<i} f(d)+a_i)$。后面那一堆是经过操作后 $a_i$ 的实际值，用 $b_i$ 减去即可。
- 操作代价就是 $\sum |f(i)|$

经过这样一波递推之后，我们可以得到每个 $f(i)$ 关于 $b_1$ 的表达式。设 $b_1=x,\ f(i)=kx+b$。

那咱相当于，已知一堆 $kx+b$，给定 $x$，求 $\sum |kx+b|$。这看起来非常的好做啊。

我们把这些绝对值函数按分界点 （即 $\dfrac{-b}{k}$）排序，每次二分得到一段前缀取正，一段后缀取负。然后就可以快速计算这个数了。

然后注意细节，就做完了。

[代码](https://codeforces.ml/contest/1605/submission/135584494)

### CF1604F

限时：50min 超时：15min （看了题解）

这题我有阴影，因为我在赛场上没做出来。

我看到这题，肯定先考虑：$c$ 怎么做？

这是常见套路。一波莫反后，设 $h(x)=\sum\limits_{i=1}^{x}\mu(i)(x/i)^2$。那么 $c(l,r)=\sum\limits_{i=l}^{r}h(r/i)$。然后就可以 $O(\sqrt{r})$ 的做 $c(l,r)$。

接下来就只能优化dp了。dp有哪些优化办法？

1. 斜率优化/单调队列优化
1. 决策单调性优化
1. dp是凸的，用奇技淫巧优化
1. dp有妙妙性质，用奇技淫巧优化

我是先考虑了4。把 $10\times 10$ 的dp打表，发现：

对于 $f(i,j)$，当 $j$ 够大的时候，$f(i,j)=i$。

> 官方题解称其为 “cute observation”。
> 实际上这个 $j>\log_2 i$ 的时候就满足了

我观察了一波小数据，以为是 $j>\sqrt{i}$ 的时候满足。

> 那你没有注意到 $50$ 的时候大于 $5$ 就满足了吗？？？

那我们的 $O(n^2)$ 的状态数就减少到了 $O(n\sqrt{n})$，转移是 $O(n^2\sqrt{n})$ 的。再加上 $c$ 的计算复杂度，此时是 $O(n^3)$ 的。

然后我再猜，它有决策单调性。把转移点打出来表，发现，确实！

然后我们用分治做转移。枚举 $j$ 这一维，复杂度是 $O(\sqrt{n}\times n\log n \times \sqrt{n})=O(n^2\log n)$，常数小，能过到 $1e4$。

> 这里一个log是分治做决策单调性的 $\log$，比较小。一个根号是计算 $c$ 的根号，也比较小。因此它常数小。

但是我肯定过不去 $1e5$ 吧，然后我死活想不到优化，限时的50min结束了。

我去看题解，发现我那个 $j>\sqrt{i}$ 猜错了，$\log$ 就可以。

接下来，我把我的 $340$ 改成 $20$，复杂度变成 $O(n\sqrt{n}\log^2{n})$，有点卡，但是过了。很快啊。

[代码](https://codeforces.ml/contest/1604/submission/135610340)

### CF1606E

我先把这题读了一下题，然后想了一会，正好赶上休息时间。而我已经想过一会了，我就只给了自己40min的限时，开始做。然而还是没能做出来= =

肯定先排序吧。我一开始以为要找规律，猜结论，我手玩了好久。没玩出啥结论。

然后我发现了这个 $500$ 的数据。我要是玩出了啥结论，应该是能做 $1e5$ 的才对。这个应该是 $O(n^2),O(n^3)$ 之类的复杂度。

然后我观察了一下我玩的东西，发现我每次活的人是一个后缀，每次死掉当前后缀的一段前缀（显然）。

我们对着这个dp。设 $f(r,n,m)$ 表示第 $r$ 轮，活着 $n$ 个人，血最多的为 $m$，方案数。显然可以转移。

写出来转移是 $O(n^4)$ 的时间，$O(n^2)$ 的空间（$r$ 可以滚）。接下来怎么做呢？

遗憾的是我没有在限时期间完成。限时结束后，我参考了题解，发现状态可以少一维。

设 $f(n,d)$ 表示，到第 $n$ 轮，每人受到伤害为 $d$，方案数。这玩意也可以转移，答案就是 $f(0,*)$。复杂度 $O(n^3)$。

[代码](https://codeforces.ml/contest/1606/submission/135740370)

### 总结

对于困难的问题，可以考虑先写一个复杂度高的傻逼做法，然后通过观察，思考，优化，逐步得到正解。

打表是个好用的策略，可以有效观察出dp的性质。

## 其它

颓废了好久。

复习了点分治的板子。

详细数据暂缺，因为颓。