1. [1217-1219 hb训练](#1217-1219-hb训练)
   1. [写题](#写题)
      1. [ABC155F](#abc155f)
      2. [CF1617E](#cf1617e)
      3. [ABC176F](#abc176f)
      4. [CF1007E](#cf1007e)
   2. [比赛: 省选模拟](#比赛-省选模拟)
      1. [A. 矩阵](#a-矩阵)
      2. [B. 序列](#b-序列)
      3. [C. 树](#c-树)
      4. [总结](#总结)

# 1217-1219 hb训练

## 写题

4个，ABC155F, CF1617E, ABC176F, CF1007E

### ABC155F

区间操作不方便，转换成差分序列上两点操作。

同 [这里](https://flandre-zhu.github.io/zhu/record/2021-12-03~07.html) 的 Codeforces 79D

把这两个点连一条边。接下来变成，有一张图，点权有0/1。每条边可以对它连接的两个点都取反，也可以选择什么都不干。要使得点权都为0。问是否可行，不要求操作次数最小。

分连通块考虑。对于一个连通块，如果操作的边形成了环，那就相当于啥也没干，删掉一个环。因此我们操作的边一定可以是无环的。也就是任取一个生成树做一下。树很simple，从下往上贪心的做即可。最后判断根是否为 0/1 即可。

代码很简单。

### CF1617E

一个观察是，对于一个数 $x$，取最小的 $k$ 使得 $2^k\ge x$ 即可。

如果每次都取一个最小的 $k$ 使得 $2^k\ge x$，那么很显然，$x$ 原来的最高位会变成 $0$。也就是 $x$ 的最高非0位在不断的变低。那很明显经过 $\log x$ 次，$x$ 就会变成 $0$。

我们把这个过程看成一条路径，并建图。一定建出来是树 （因为不断变小）。

然后问题就变成树上有若干关键点，求距离最远的一对的距离。类似直径，两遍dfs即可。

$x$ 可能很大，需要给点进行一个重标号。它和离散化的区别是它不需要考虑相对大小，因此比离散化好写。

### ABC176F

这是个热身dp题，对于后面的毒瘤dp题1007E来说，相当于热身了一波。

每次五选三，相当于留下两个。

我们先设计一个dp：做到 $i$，留下的两个是 $x,y$，最大得多少分。$i$ 每次增加 $3$ 个转移。

如果记位置，我们需要一个很大力的讨论三个是否是相同的，如何如何转移。复杂度大概是 $10O(n^3)$，这个 $10$ 是从 $\{x,y,i+1,i+2,i+3\}$ 中取两个的枚举复杂度。而且这个形式一看就没法优化，没有前途。

最关键的是这个做法没有利用到值域是 $[1,n]$。

考虑记录值。即，$f(i,x,y)$ 表示做到 $i$，剩下的两个值是 $x,y$，最大的得分。

依然是每次跳 $3$ 个。设 $i+1,i+2,i+3$ 的值分别是 $a,b,c$。考虑转移：
- 到 $f(i+3,a,b)$。$f(i)$ 剩下了不知道啥，和 $c$ 组一组。我们假设它没有贡献相等。直接令 $f(i,*,*)_{\max} \to f(i+3,a,b)$。这里需要维护一个全局最大值。
- 到 $f(i+3,a,b)$。$f(i)$ 剩下了两个 $c$，和 $c$ 凑一组，得一分。$f(i,c,c)\to f(i+3,a,b)$
- 到 $f(i+3,a,x)$。$f(i)$ 剩下了 $x,y$，$y$ 和 $b,c$ 凑一组。$f(i,x,*)_{\max} \to f(i+3,a,x)$。这里需要维护一个某行/列最大值。
- 上一种转移，如果 $b=c$ 且 $y=b$，那么可以得一分。转移：$f(i,x,b)+1 \to f(i+3,a,x)$

另外还有一些对称的情况，省略。总结一下，我们需要：

- 单点访问
- 维护某行/某列的最大值
- 维护全局最大值

都可以 $O(1)$ 的修改并维护。并且第一维 $i$ 可以用原地修改来优化掉空间。复杂度是 $O(n^3)$。

细节：转移的时候，需要用vector先记录所有的转移，到最后一并转移，并维护全局最大值和行列最大值。

### CF1007E

一个很 **难** 的dp题。

本题解（大）部分参考了 [yhx 的题解](https://yhx-12243.github.io/OI-transit/records/cf1007E.html)

先做一会，发现我们似乎要把每个站的人数记录在状态里。这根本没法记。

但是想一想发现好像也没别的转移。那怎么办。

本题的突破口在于，我们强制令每次都 **恰好** 接走 $K$ 个人。

但这样不一定可行，因为总人数不一定是 $K$ 的倍数。我们在 $n+1$ 位置放一个 (INF,0,INF) 的点，作为“缓冲”，并且最后我们不管它。这样，我们每次恰好接 $K$ 个，也是能够有解的。

那么我们接下来的dp都要依着 **恰好** 接走 $K$ 个人。不要怀疑它的正确性，它一定有解。

然后考虑dp。设 $f(i,j)$ 表示，前 $i$ 个站，坚持 $j$ 轮，最少几个车。

> 这个应该说是一开始就能设出来的，只不过不知道如何转移

如果前面的车都没有碰到过 $i$ 车站的人，那么 $f(i,j)\leftarrow f(i-1,j)$。需满足：$a_i+jb_i\le c_i$。

如果有碰到过的，设最后一次在第 $r$ 轮。那么在第 $r$ 轮的时候，$[1,i-1]$ 应该是空的。我们有必要知道这里用了多少步。因此设 $g(i,j)$ 表示前 $i$ 个车站到第 $j$ 轮清空最少需要多少车。

> 这一步考虑是进一步向前的关键，当然，它是基于上一个转化的。
> 
> 转化加上这一步，整个问题才能继续往下做。

假设我们设了这个 $g$，考虑 $f$ 的转移。首先加上 $g(i,r)$，然后把 $i$ 的 “潜在威胁” 清空。接下来，$i$ 就不用管了，需要做一下 $[1,i-1]$。这其实是子问题，但一个区别是它们的初始值是 $0$ 而不是 $a_i$。这个好做，在 $f$ 后记一维 $0/1$ 表示初始值为 $0/a_i$ 的情况。

重新来一遍。

1. 如果前面的车都没有到 $i$。
   - 满足 $a_i+jb_i\le c_i$ 且 $f(i-1,j)<INF$，更新 $f(i-1,j)\to f(i,j)$
   - 令 $N=\sum\limits_{x<i} a_x+jb_x,N'=\sum\limits_{x\le i} a_x+jb_x$。若 $K\lceil\frac{N}{K}\rceil \le N'$，更新 $g(i,j)=\lceil\dfrac{N}{K}\rceil$
   - 这里的转移，最后一维 $0/1$ 不动
2. 最后一次接到 $i$ 在 $r$ 时刻，$r$ 枚举。设后面那一维 $0/1$ 是 $k$，注意与 $K$ 区分
   - 首先需要 $g(i,r,k)$ 个车，清空
   - 第 $i$ 个位置剩：$rem=(\sum\limits_{x\le i} ka_x+rb_x)-Kg(i,r)$
   - 第 $i$ 个位置会变成 $rem+b_i(j-r)$，可能超过 $c_i$。这部分需要清掉。
   - 需要 $need=\lceil \dfrac{rem+b_i(j-r)-c_i}{K} \rceil$ 步解决这个，但要满足 $K*need\le rem$
   - 若满足，更新 $g(i,r)+need+f(i-1,j-r,0) \to f(i,j,k)$
   - $g$ 差不多。设 $N=\sum\limits_{x<i} (j-r)b_x$，$N'=N=\sum\limits_{x\le i} (j-r)b_x$。
   - 需满足 $K\lceil\dfrac{N}{K}\rceil \le N'$，更新 $g(i,r)+need+\lceil\dfrac{N}{K}\rceil \to g(i,j,k)$

这里每个 “需满足...”，多数就是要注意，我们必须 **恰好** 每次接走 $K$ 个。

然后注意细节写出来就可以了。需要开 long long。

[代码](https://codeforces.com/contest/1007/submission/139985644)

## 比赛: 省选模拟

周六，号爸举行了一场省选模拟赛。

我应获得160分(rk 5)。但是我文件名写错了，喜提0分。

赛场: 20+100+40

赛后: 补完

### A. 矩阵

原题是 NOIP2017 列队，但这题卡常。只有树状数组和常数很小的平衡树能过。

考虑每一行维护前 $m-1$ 个，并单独维护最后一列。

对于循环位移，我们相当于要删除一个数，并插入在最后面。插入在最后面，可以直接接在序列的最后面。删除一个数，可以直接在这里标记一个删除。每次查找第 $k$ 个的时候，就找第 $k$ 个没被删除标记的位置即可。这个可以用线段树二分，平衡树二分，树状数组二分等二分来实现。

但是这样我们需要 $n+1$ 个树状数组/平衡树/线段树。线段树或平衡树可以用动态开点AC，但是树状数组不太好动态开点。

我们发现位置与值是分开的。也就是说，我们每次操作都是先找一个位置，然后取这个位置的值，再做后续的操作。

考虑离线。我们开一个树状数组，先把每次操作要用到的位置搞出来，然后后面再把值填进去。关于值的维护，我们注意到，设每行后面新接的数为 “额外空间”。那么额外空间的总量是 $O(q)$ 的，直接开数组即可。

对于不是额外空间的位置，可以用 $(x-1)m+y$ 来计算这个位置的值。

然后模拟一遍就行了。 [代码](https://paste.ubuntu.com/p/6wc2BRxPdt/)

### B. 序列

原题是 CTSC2009 序列变换

在 [这里](https://flandre-zhu.github.io/zhu/methods/misc-tricks.html) 第一个trick

### C. 树

和上题一样，是个slope-trick

这里讲一下slope-trick如果斜率差不是1，怎么维护。

很简单，开一个map，map的first表示断点位置，second表示斜率的差，然后记录一下左右斜率，就行了。

然后这个东西是支持启发式合并的。

本题就是维护一个凸壳，每个位置的凸壳是儿子凸壳的和，然后拿它和父亲那条边的 $w$，来切这个凸包。左边用 $-w$ 来切，右边用 $w$ 来切。这个切凸包的意思是，如果我要对子树整体 $+1$，那么我可以选择动这个 $w$，也可以选择递归到每个子树里去 $+1$。但是直接动 $w$ 可能更优，要取 $\min$。然后发现这个取 $\min$ 其实就是拿斜率为 $-w,w$ 的线去切凸包。

这个好做，就是像单调队列一样左右看一下就行了，不行就弹掉。

然后就启发式合并一遍，得到最终的最优解，再倒推回去，得到每条边选了啥，算一遍就可以得到总代价了。细节较多，需要自己推很多东西。这里略。

[代码](https://paste.ubuntu.com/p/TZwJjXyQs2/)

### 总结

学会了更加广义的slope-trick维护！

NOIP2017列队那个题我是做过的，但是我忘记做法了。

写这篇文章是12.22，这天我也发现我做过的一个题我忘记怎么做了。

因此我觉得我很有必要重温一下我做过的题。