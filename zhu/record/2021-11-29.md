# 2021.11.29

hyh那个鸟人一直搞我qaq

但是他好强啊

## 做题

做了ARC130的C,D

### C题

如果不进位，答案就是A,B的位和的和

进一次位，答案减少9。相当于要让答案减少的最多。

当最低位和 $>=10$，前面连续一段和 $>=9$ （注意 $0+9$ 的情况），容易发现，此时能产生连续的进位。并且进位次数最多一定是这样进位。

（注意到每个位置最多进1）

然后可以贪心。如果不想贪心，直接写个网络流即可。

### D题

想了好久，看题解做出来的。

值得反复回味的一个题。

等价的转化一下，每个点要么比周围都大（称为大点），要么比周围都小（称为小点）。

分配大小点的方案只有恰好两种，相当于黑白染色。

一种思路是把大小关系建出有向图。此时这个有向图是个二分图。求它的拓扑序数量。

简单思考，这东西不太好做。我们换一下。

接下来就容易想到树形dp了。注意到 $n^2$ 的复杂度，设 $f(u,x)$ 表示 $u$ 子树里，$u$ 权值为 $x$，方案数。

对于大点，就让 $v$ 的权值都小于 $x$，否则都大于 $x$。但是这样有一个问题：子树里面可能会有和 $x$ 相等的，与题意不符。这是这个状态的局限性，是无法解决的根本问题。

因此，咱换一个状态来设。可以从许多树形排列计数的问题中获得这个思路：设 $f(u,x)$ 表示 $u$ 的子树里，$u$ 排名 $x$，方案数。

> “其它树形排列计数问题”，暂时没有例子，我只是记得做过

转移的时候用组合数来分配选择空间，确保不重复这个条件满足。

直接对着全部的子树做，相当不好做。考虑逐一合并子树。

设更新出来的dp是 $f'$，当前的是 $f$。当前儿子是 $v$。

枚举 $u$ 排名 $x_1$，$v$ 排名 $x_2$，更新完之后是 $x$ 名。即，我们要求 $f(u',x)$。设 $n$ 为 $u$ 当前子树大小（即，$u$ 本身，与计算过的子树），$m$ 为 $v$ 子树大小。

$x$ 之前有 $x-1$ 个东西。其中来自 $u$ 的有 $x_1-1$ 个。剩下的那些，就强制分配给 $v$，因此不用数。这里方案数就是 $\binom{x-1}{x_1-1}$。

$x$ 之后有 $n+m-x$ 个东西。其中来自 $u$ 的有 $n-x$ 个。这里方案数是 $\binom{n+m-x}{n-x}$

然后乘上 $f(u,x_1)\times f(v,x_2)$，加到 $f'(u,x)$ 即可。

注意到两个组合数与 $x_2$ 都没有关系，用前缀和优化掉 $x_2$。此时合并复杂度是 $O(n(n+m))$。

再注意到，$x_1\le x \le x_1+m$，$x$ 的枚举范围缩小为 $m$。复杂度变为 $O(nm)$。

这样复杂度就对了，总共是 $n^2$ 的。

思路总结：
- 小转化，然后想到dp
- 试一试状态，发现 $f(u,x)$ 表示 $u$ 子树里 $u$ 权值排名为 $x$，这个好使
- 写出暴力的dp转移，优化。
  > 优化前，联想到经典“树形背包”的复杂度证明，只要能 $O(nm)$ 的合并，就能过
  > 
  > 对着这个做，往这方面想，就想出来了。

lzj同学的思路：

> 首先也是“大点”“小点”的转化。接下来考虑dp。
>
> 考虑还需要哪些信息才能dp。考虑维护出每个子树里的权值的ov （排序后的序列）。如果 $u$ 是小点，$v$ 是大点，那么 $v$ 合并过去，一定要排在 $u$ 的后面。
>
> 由此想到我们需要记排名。
> 
> 后续的转移和优化，与本篇相同。