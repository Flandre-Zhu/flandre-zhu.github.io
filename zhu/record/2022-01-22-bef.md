# 期末whk复健练习

从1月几号考试，一直到2022.01.22之前。这一段时间要么在whk，要么在颓废，OI练的很少。

## 洛谷7039

面积用叉积搞。

先搞一个式子出来，然后搞一个前缀和，区间的面积就可以写成关于 $l$ 一堆 + 关于 $r$ 一堆 + 关于 $l,r$ 一堆。

枚举 $r$，维护一下各种东西的奇偶性，以及其数量，然后就可以数了。

[代码](https://paste.ubuntu.com/p/DtSzvnsNF4/)

我被骗了，一开始以为这是个dp，想来练练dp的。没想到是个垃圾题。 正好拿来复健。

## 洛谷1399

这倒是个有趣的题。我没有独立的搞出来。

对于一颗树，很显然答案是直径/2。

接下来转化一下原问题。我们要找一个点（可能是原来的点，可能在原来的边上任意位置），算出它到每个点的最短路后，使得最短路的最大值最小。能否转化成树呢？

注意到跑最短路之后，一定有一条环边没有被用到。原因是：这个点到环上的每个点都有两种走法，按几何形状排列后，我们称它们为“顺时针走”和“逆时针走”。顺时针走比较近的那些点，一定在顺时针方向上是连续的一段；逆时针同理。而处在二者分界线上的那条边，就一定不会走到。

如图:

![](https://s2.loli.net/2022/01/21/AgQT8S6zDZltUJN.png)

从S出发，有两种走法。绿色线表示，顺时针走更近的那些点；蓝色线表示逆时针走更近的那些点；而中间那条红线，不会被走到。

因此我们可以枚举这条边，然后剩下的部分就是树了！然后我们要在树上找一个点，使得它到每个点的最短路的最大值最小。上面提到，这个数就是直径/2。

我们要最小化答案。因此要切掉每条边，求直径的最小值，除个2就是答案。如何求最小值呢？

考虑预处理，然后 $O(1)$ 算切掉每条边的答案。

首先环外的那些树的直径先搞出来，切每条边的答案都要和这个数取max。

对于基环树，我们常考虑断环为链（复制一倍）。然后切掉一条边后剩下的链就是这条两倍长的链上的一段区间。

设每个点的环外子树深度为 $d_i$，链上的边权的前缀和为 $s_i$。那么一段区间 $[l,r]$ 的直径为 $\max\{s_j-s_i+d_i+d_j| l\le i<j\le r\}$

然后有两种做法。一种是线段树做，复杂度 $O(n\log n)$。当然，也存在线性做法。

设环长为 $m$。首先特殊处理切 $1,m$ 的情况。接下来是切 $i,i+1$ 的情况，而此时它一定包含了 $1,m$ 这条边。体现在链上就是它跨过了第一个周期和第二个周期的分界线 $m,m+1$。设链上的这个区间为 $[l,r]$ （$r-l+1=m$）。处理：
- $p(l)$：区间 $[l,m]$ 中，$\max\{s_j-s_i+d_i+d_j\}$
- $p(r)$：区间 $[m+1,r]$ 中，$\max\{s_j-s_i+d_i+d_j\}$
- $q(l)$：区间 $[l,m]$ 中，$\max\{d_i+s_m-s_i\}$
- $q(r)$：区间 $[m+1,r]$ 中，$\max\{d_i+s_i-s_m\}$

都很好处理，就递推一遍即可。然后 $[l,r]$ 这段区间构成的树的直径就是 $max\{p(l),p(r),q(l)+q(r)+w,d_0\}$。其中 $w$ 表示 $1,m$ 边的边权，$d_0$ 表示环外子树的直径的最大值。

注意一下细节。

[代码](https://paste.ubuntu.com/p/7YHXKjCb7T/)

## CF797F

眼睛看。每个耗子肯定到比较近的那个洞里去。简单想想肯定是，连续一段耗子进一个洞。

然后做一个区间分段的dp。先把耗子们按位置排序，然后就是 $f(i,j)$ 表示前 $i$ 个耗子都跑到洞 $j$，最小花费。

$f(i',j-1)+w(i'+1,i,j)\to f(i,j),\forall i'<i$。$w(l,r,p)$ 表示 $[l,r]$ 耗子都跑到洞 $p$ 的花费。转移的时候注意处理一下每个洞的容量限制。

然后枚举第二维 $j$，$w$ 可以通过预处理 $O(1)$ 算，复杂度为 $O(n^3)$。

打表发现转移点具有单调性。用一波决策单调性的优化，变成 $O(n^2\log n)$。由于 $n$ 是 $5000$，因此这个 $\log$ 较小，可以过。常数没卡过不怪我。

[代码](https://paste.ubuntu.com/p/KwgSXKdqWt/)

## AGC017F

小 清 新 复 健 d p 题

首先考虑暴力dp。$f(i,s)$ 表示到第 $i$ 个线，状态为 $s$，方案数。枚举一下上一个状态看能否转移，复杂度 $O(4^n)$ 左右。

能转移当且仅当：满足 $(A,B,C)$ 的限制，并且当前状态的前缀和每个位置都 $\ge$ 上一个状态的前缀和。

简单想一波，我们可以一步一步的决策，然后做轮廓线dp。
对于第 $i$ 个线的第 $j$ 步，“轮廓线”需要记录：
- 前 $j-1$ 步怎么走的 （01状态）
- 第 $i-1$ 个线在 $j$ 步之后怎么走的 （一个位置 $p$ +一个01状态）（位置 $p$ 表示第 $i$ 个线 $j-1$ 步走到哪）

dp改写成 $f(i,j,p,S)$，转移是 $O(1)$ 的，实现较为复杂 （对 $S$ 的操作要求较高）。复杂度 $O(n^3 2^n)$ 且常数大。冲不过去。

真的需要 $p$ 吗？

考虑怎么去掉 $p$。先想好，原来的 dp 中，$p$ 的作用是限制左边（描述限制线的起点，线的走向由 $S$ 的后半部分描述），我们不能越过那条限制的线。

这个限制是必要的，就算我们去掉了 $p$，还是得想办法限制。那去掉了 $p$ 之后，如何确定限制线的起点呢？

注意到这个限制线并不是“确界”，因为有些地方太左了，我们走不到那边，哪怕一路往左也冲不到那么左。那这些点的限制就是无用限制，可以删去。也就是说，我们可以把原来的限制线，和一路向左的链取max。然后这个限制线的起点就一定是当前点了。

如图：

![](https://s2.loli.net/2022/01/23/WtDfQpR1JXSiCTG.png)

红色是当前的线 $i$，蓝色是线 $i-1$。当前已经走了一步。

接下来，固然可以用蓝色来限制。而实际上粉色的就够了，因为这两者中间夹的那一块我们无论如何都走不过去。

接下来dp变成，$f(i,j,S)$ 表示：第 $i$ 个线，正在走第 $j$ 步（走完了 $j-1$ 步），轮廓线为 $S$ 的方案数。“轮廓线”定义：前半部分为已经走过的线，后半部分为上面描述的新限制线。注意到这两个线可以以当前点为连接点接在一起，因此用一个01状态 $S$ 就可以表示。

这样的表示细节也少了很多。如果我们沿着限制的线走，直接就是转移到 $f(i,j+1,S)$，非常简单。

如果不沿着线走，那只能是线往左我们往右（因为线往右时我们不能往左）。然后这种情况需要把线调整一下，把当前的 $0$ 变成 $1$，并把后面第一个 $1$ 变成 $0$。我的代码中，往下是高位。因此我们需要把 $S$ 的第 $j$ 位翻转，然后找到 $S$ 超过 $j$ 的第一个 $1$，并把它翻转成 $0$；如果 $j$ 往后没有 $1$ 了，那就不翻转。这里说的话都可以通过画图来理解，并且可以用简单的位运算实现。

[代码](https://paste.ubuntu.com/p/B4MCMYy87S/)

## uoj275

垃圾数位dp题。

由Lucas定理，在 $k$ 进制下，满足 $i\ge j$ 且 $i$ 存在一位严格小于 $j$ 的对应位，即可。

可以用（$i\ge j$ 的方案数）-（$i$ 每一位都$\ge j$ 的对应位方案数）来做到这个。

后面那个是一个非常简单的数位dp。

[瞎写的垃圾实现](https://uoj.ac/submission/528481)

[复杂度优化版](https://uoj.ac/submission/528492)

## AGC009D

【注】后文称 $U$ 值，即原题的 Uninity。

最优决策一定是每次删重心。但是重心可能有两个，因此直接做不好做。

我想了半天如何确定两个里选哪个，没想出来。

称这个带有自主决策 （选哪个重心） 的点分治为自定义点分治。对应的点分树为自定义点分树。

对于这个自定义点分治，考虑切每个点 $i$ 时当前树的 $U$ 值。即，每个点在自定义点分树上的子树 $U$ 值。记这个 $U$ 值为 $a_i$。

对于一个决策，很容易求出生成的序列 $a_i$，且 $a_i$ 唯一。对于一个（合法的）序列 $a_i$，也可以得到一个决策（每次切 $a_i$ 最大的）。因此它俩是一一对应的。

因此合法的 $a_i$ 的最大值的最小值，就是答案。

考虑刚才 “序列->决策” 的对应过程，每次需要切 $a_i$ 最大的。易得这个最大值应该是唯一的，因为这代表当前切的点，切完之后剩下的点的 $a_i$ 肯定比当前点都（严格）小。

想想发现这是充分必要的。因此，$a_i$ 合法的等价条件是，对于当前切剩下的子树，子树里的 $a_i$ 值应该有唯一的最大值（最大值位置就表示当前子树切在哪）。

这个条件再转化，就是：如果 $a_x=a_y$，那么 $x,y$ 肯定被某个点 $k$ 切到了两个子树里去，且 $a_k>a_x,a_y$。

切到两个子树里去，那么 $x,y$ 路径上一定过 $k$。条件进一步等价的转化为，$\forall a_x=a_y$，$x,y$ 的路径上存在一个 $k$ 使得 $a_k>a_x,a_y$。这里“路径”指原树上的路径（不是自定义点分树上的路径，这点要想清楚）。

然后我们就可以在原树上搞了，从下往上贪心。对于当前的点 $u$，它被子树里拥有相同 $a_i$ 的点对限制，我们需要使 $a_u$ 最小化（易证这样可以让 $a_i$ 的最大值最小化）。维护出子树里的限制即可。

对于子树里的某个点，假设另一个子树里有个和它拥有相同 $a$ 值的点。但是这个点上面不到 $u$ 的位置，已经有一个 $a$ 值比它俩大的点，那 $a_u$ 就不被它们限制：它俩的条件已经满足了。

只有那些点 $x$ 满足：$x$ 上面不到 $u$ 的路径上的点，$a$ 值都 $\le a_x$，这样的 $x$ 才有实际限制作用。称 $u$ 某个子树 $v$ 里，这样的 $x$ 的 $a$ 值集合为 $S(v)$。 （注意集合里记的是 $a$ 值）

那么，

- $\forall x\in S(v),a_u\neq x$，$v$ 为 $u$ 的儿子
- $\forall x\in S(v_1)\cap S(v_2),a_u>x$，$v_1\neq v_2$ 且均为 $u$ 的儿子

记 $X=\bigcup S(v),Y=\bigcup S(v_1)\cap S(v_2)$。这俩均可以一边加入子树一边维护。然后 $a_u$ 不仅不能在 $X$ 里面，还得超过 $Y_{max}$。很容易处理出它的最小值。

然后 $S(u)$ 显然就是把 $X$ 和 $a_u$ 并起来，然后去掉 $<a_u$ 的就行了。

由于 $a$ 的值不超过 $\log$ （由点分治结论），这个 $S$ 可以用一个 int，用状压来维护。复杂度是 $O(n)$ 的 （位运算 $O(1)$）

[代码](https://paste.ubuntu.com/p/xbhZKT9jPs/)