## 优先队列维护凸包（凸dp）的折点

这个东西也叫做 slope trick

众所周知，一个凸包，它由很多条线段。上半部分，斜率单调递减；下半部分，斜率单调递增。我们称一半为“凸壳”。上半部分是上凸壳，下半部分是下凸壳。

现在有一个dp，设为 $f(i,j)$。对于固定的 $i$，$f(i,j)$ 是凸的（不妨设它是个下凸壳）。并且它的转移也是叠加上一个比较简单的凸函数，再做某某某操作，并满足转移之后也是凸的。

此时我们可以用优先队列维护凸壳的转折点，并通过对顶堆的技巧，找到中间那个点，也就是最小的那个。

> 对顶堆：开两个堆。一个常见的应用是动态求中位数，我们用一个小根堆维护排名前一半的数，和一个大根堆维护排名后一半的数。每次加入数的时候，维护一下二者的平衡，取第一个堆的top就是中位数了。
> 
> 这里可以用类似的技巧，开两个堆维护最值点左半边和右半边的转折点位置

那么我们叠加上一个简单的凸函数之后，转折点如何变化呢？

设原来那个下凸壳为 $f$，加上一个简单的凸函数 $g$，变成 $h$。

考虑转折点，它的本质是斜率的变化导致的。加上 $g$ 之后，对于某一段区间，如果 $g$ 和 $f$ 在这段区间中都是一条直线，那么 $h$ 在区间里还是一条直线。但是只要 $f,g$ 两者有一个断了，就会 $h$ 形成一个断点。

“二者取一即成立”，是一个“或”的关系。因此我们把两个断点集合取并集即可。这就是把两个区间的划分归并起来，变成一个新的划分，使得原来不在一段的现在还不在一段。感性理解一下，就是 “把切的两组刀一块切”。

随便举个例子，比如绝对值函数。假设咱原来有个下凸壳，它的转折点在 $-1,1,4,5$。现在把这个函数加上了一个 $g(x)=|x-2|$。

在 $<2$ 的部分，原来断点是 $-1,1$，现在还是这两个点。因为直线加直线还是直线，但加的直线斜率一样（注意到，绝对值函数的两半边绝对值是恒定的，左边都是 $-1$，右边都是 $1$），因此原来斜率不同，现在斜率还是不同。因此这里的断点还是只有 $-1,1$ 两个位置，不增加新的断点。右边同理。但是 $2$ 这个位置断了，要注意。

可得，加一遍之后，得到函数的断点是 $-1,1,2,4,5$。可以画个图验证这个结论。

因此，加入一个简单的凸函数后，如果它的断点很少，就直接插入进维护的对顶堆中，就可以维护新函数的断点了。

根据实际问题的不同，新的函数可能还要做一些操作，比如取个min等。这个视情况而定。

接下来是例题捏

### CF1602E Optimal Insertion

<details>
<summary> 点击展开题解 </summary>

前几天刚打的CF。看到hyh写的是这个写法，一问他才知道有这个方法，整理了这篇博文。

> 这个写法比我写的傻逼线段树短很多，简单很多，不知道高到哪里去了！

显然把 $b$ 排序。然后先算出来 $a$ 的逆序对数，之后就考虑 $a,b$ 之间相互影响的贡献。

假设俺们有一个序列 $a$，有序的。考虑这样一个函数：$ins(x,i)$，表示 $x$ 插到 $i$ 前面之后产生的逆序对数。

如果 $i$ 使得 $x$ 插到 $i$ 前面之后 $a$ 有序，那么 $ins(x,i)=0$。容易发现，这样的 $i$ 间于 `[lower_bound(x),upper_bound(x)]`。设 $l=lowerbound,r=upperbound$

如果我们把 $i$ 放到外面，比如说，$r+k$ （右边）。每往右动一个，都会导致一个比它大的人跑到 $x$ 前面，因此逆序对数会 $+1$。因此，$ins(x,r+k)=k$。同理，$ins(x,l-k)=k$。$k>0$。

一拍脑袋，这玩意是凸的！并且只有两个断点 $l,r$。我们把它叫做一个 “碗”。

> 这玩意等于 $\dfrac{|x-l|+|x-r|-(r-l)}{2}$。根据这个，你可以在数学软件中用公式画出这个函数。
> 
> “碗”是我一拍脑袋随便胡的名字，还行吧

这玩意有啥用？原题是把 $b$ 插到 $a$ 里，但其实都是混一块，没啥区别。咱们考虑把 $a$ 插到 $b$ 里。

> 为啥？因为 $b$ 有序，可以利用 $ins$ 这个函数的妙妙性质

$f(i,j)$ 表示插了 $a$ 的前 $i$ 个，$a_i$ 恰好插到 $j$ 前，最小代价。

$f(i,j)=\min \{f(i-1,j'),\ j'\le j\}+ins(a_i,j)$。$f(i,*)$ 这玩意是凸的。如何证明？

> 我们一边考虑证明，一边挖掘性质，以便后面维护

分两步。首先把 $f(i-1,*)$ 取个前缀 $\min$，然后叠加上函数 $ins(a_i,*)$。

一个凸的玩意取前缀 $\min$，相当于把右边增的那一半推平了，还是凸的。然后叠加一个凸的函数，依然凸。证毕。

考虑按这个来维护。由于右半边被推平了，咱们省了很多事，比如说少维护一个右半边。

假设加入的“碗底” $[l,r]$ 在当前凸壳平台的右边，那么 $l$ 会成为平台上的一点，作为左端点。因为 $[l,r]$ 这个碗会让 $l$ 左边变大，原来平台被抬高，导致 $l$ 成为新的平台的左端点。但这个新的平台不增加高度，因为 $ins(a_i,[l,r])=0$。整体来看，平台高度不变，只是位置变了。此时，只需要把 $l$ 加进堆里即可，因为 $r$ 到右边去了。

而如果 $[l,r]$ 不在右边，根据 `lowerbound` 与 `upperbound` 的性质，一定在左边。此时它会对平台有影响。容易发现，这个“碗”的斜率变化都是 $1$（$-1\to 0\to 1$）。因此当前的平台左边那一段，斜率一定是 $-1$。而加入了这个“碗”之后，左边这一段 $-1$ 斜率的线，就会变成 $0$ 斜率的线，从而形成新的平台。原来平台的右端点就会变成新平台的左端点。同时 $l,r$ 也会变成断点之一。

如何统计答案呢？容易发现，答案就是最后 $f(i,*)$ 的最小值，也就是“平台”的高度。碗加在左边会影响高度，加在右边不会。累加一下即可。

最后加上 $a$ 初始的逆序对数才是答案，注意。

代码写起来非常的短啊。

[代码](/zhu/methods/src/CF1602E.html)

</details>

### [CTSC2009]序列变换

<details>

<summary> 点击展开题解 </summary>

这个题面定义的变量名不行。像tzc题解里一样，咱们也写作 $a,b,l,r$。

那就是要找一个 $b$，使得 $b_{i+1}-b_{i}\in [l,r]$。最小化 $\sum |a_i-b_i|$。

注意到 $b_1\ge 1$。因此 $b$ 应该至少是 $1,1+l,1+2l,...$，即 $b_i\ge 1+(i-1)l$。

也就是说 $a_i$ 至少变成这个数。如果 $a_i$ 小于这个数，就强制变过去，并记得统计一波答案。现在咱已经变好了，再令 `a[i]-=(i-1)*l+1`。对应的，我们求 $b$ 的时候，也让 $b_i$ 减去 $(i-1)l+1$。同时减，绝对值不变。但是这样搞完之后好处理一些，因为 $b_{i+1}-b_i$ 的限制变成了 $[0,r-l]$。一边变成 $0$，好看点。设 $K=r-l$。

现在是 $b_{i+1}-b_i\in [0,K]$，要求最小化代价。

一个naive-dp：$f(i,j)$ 表示搞完前 $i$ 个，$b_i=j$，最小代价。

称 $a\to b$ 表示用 $a$ 更新 $b$。计数题就是 `+=`，最优化题就是取 min/max。

$f(i-1,j-k)+|j-a_i|\to f(i,j),\ \forall k\in[0,K]$

$|j-a_i|$ 是定值，提出来。然后分两步转移：首先找到 $f(i-1,j-K...j)$ 的最小值，令 $f(i,j)=$ 这个，然后把 $f(i,j)$ 加上 $|j-a_i|$。

发现 $f(i,*)$ 是个凸的函数。同上，我们一边考虑证，一边挖性质。

假设 $i$ 在平台上，并且 $i-K\le u$。根据凸的性质，左边递减，直接取 $i$ 最优。因此，取min对这一段没有影响。

对于 $v+K$ 之后的部分，由于 $i-K/ge v$，根据单调性，取 $i-K$ 最优。相当于是平移，把 $v$ 往后的部分向右平移了 $K$ 个单位。那还剩下一段，$u+K$ 到 $v+K$ 的部分。注意到这一部分里取在平台上最优。

因此这一波取min，相当于是把现在这个凸壳的“平台”延长了 $K$ 个单位，并向右挤掉了右半边的函数，对左半边没有影响。容易发现，它不改变凸的性质。

接下来，我们要把这个凸壳叠加上一个函数 $g(x)=|x-a_i|$，也是个凸的函数。显然加上之后还是下凸壳。

由此可以归纳证明，$f(i,*)$ 是凸的。

由此我们也可以发现维护的方法。开两个堆 $L,R$，维护“平台”左右的转折点。每次把 $R$ 中的每个元素都 $+K$，并插入一个 $a_i$。注意维护对顶堆的平衡。

插入数好做，怎么实现平移？就是全体 $+K$。

这里有个小技巧：注意到我们每一轮都加，一个元素但凡进来，随着时间的推移，就会一直被加。

在 $i$ 时刻，我们插一个 $x$ 进 $R$ 的时候，扔进去一个 $x-i*K$。取的时候，假设是 $i'$ 时刻，把取出来的 $x$ 加上 $i'*K$。这样就比原来进来的那个值多了 $(i'-i)*K$，而这正是我们想要的。每一轮都 $+K$，从 $i$ 到 $i'$，确实会加上 $i'-i$ 个 $K$。

维护凸包到最后，取平台上的一点，就是 $b_n$ 的值。注意到凸壳的最值位置会变，就是说，最后取到最值的位置，如果一路追溯回去，它在前面的时刻不一定是最值的位置。因此我们需要反推一遍回去。

[代码](/zhu/methods/src/CTSC2009-Sequence.html)

</details>