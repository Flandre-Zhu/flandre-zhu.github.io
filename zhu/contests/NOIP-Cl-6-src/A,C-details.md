# A,C 两题详解

## A

不妨设 $v_1<v_2$

我们要求的实际上是，满足如下条件的 $t$ 的数量：

- $0<t\le T,t\in \R$
- $(v_1+v_2)t=(2k+1)L$，或 $(v_2-v_1)t=(2k+1)L$，其中 $k\in \N$

第一条是个范围限制，好说。第二条是一个 “或” 的关系，我们分别求两边，并减去两边同时满足的数量。

注意到一个 $k$ 可以对应一个 $t$。对于求一边的问题，考虑数 $k$。

假设 $k$ 已知，可得 $t=\dfrac{(2k+1)L}{v_1+v_2}\le T$。

因此 $(2k+1)\le \dfrac{T(v_1+v_2)}{L}$

由于 $2k+1$ 是整数，右边可以取个下取整。设 $M=\lfloor \dfrac{T(v_1+v_2)}{L} \rfloor$，那么 $2k+1\le M$。相当于不超过 $M$ 的奇数个数。简单推一下发现它等于 $(M+1)/2$。

右边一样算，就是把 $v_1+v_2$ 换成 $v_2-v_1$ 代入算一下就行了。

接下来处理二者同时满足的情况。由于二者的 $k$ 并不共用，因此不能数 $k$ 了，要数 $t$。

注意到 $(2k+1)$ 和 $L$ 都是整数。因此 $t$ 可以不是整数，但是 $(v_1+v_2)t$ 和 $(v_2-v_1)t$ 都得是整数。这么说 $t$ 至少得是有理数。

设 $t=\dfrac{p}{q}$。那么 $q$ 得是 $g=\gcd(v_1+v_2,v_2-v_1)$ 的因数。否则不可能满足上面的条件。我们不约分，然后直接令 $q=g$。那么 $p$ 应该是整数，且 $0<p\le Tg$。$p$ 和 $t$ 一一对应，因此我们可以数 $p$。

设奇数集合为 $S$。限制化为：

$$
\begin{cases}
\dfrac{p(v_1+v_2)}{gL}\in S\\
\dfrac{p(v_2-v_1)}{gL}\in S\\
\end{cases}
$$

（这里省略了 $k$，把 $=2k+1$ 换成了 $\in S$，这俩显然等价）

先做第一个，第二个同理。注意到 $(v_1+v_2)$ 是 $g$ 的倍数。因此设 $A=\dfrac{(v_1+v_2)}{g}$。

那么 $\dfrac{Ap}{L}\in S$。那至少 $Ap$ 得是 $L$ 的倍数，然后除完了还得是奇数。

简单想一下，$p$ 得是 $\dfrac{lcm(A,L)}{A}$ 的倍数。设 $p=x\times \dfrac{lcm(A,L)}{A}$。化为 $x\times lcm(A,L)\in S$。

那么 $lcm(A,L)$ 和 $x$ 都得是偶数。$lcm(A,L)$ 是常数，先判掉。否则 $x$ 也要是奇数，即，$p$ 是 $\dfrac{lcm(A,L)}{A}$ 的奇数倍。

另一边，设 $B=\dfrac{(v_1+v_2)}{g}$，可得 $p$ 是 $\dfrac{lcm(B,L)}{B}$ 的奇数倍。

设 $X=\dfrac{lcm(A,L)}{A}$，$Y=\dfrac{lcm(B,L)}{B}$。那么 $p$ 要同时是 $X,Y$ 的奇数倍。

设 $p=k\times lcm(X,Y)$。如果 $X,Y$ 满足：$\dfrac{lcm(X,Y)}{X}$ 和 $\dfrac{lcm(X,Y)}{Y}$ 都是奇数，这样的话，如果 $k$ 是奇数，那么 $p$ 满足条件。

此时，$p$ 的数量是 $\left\lfloor\dfrac{\dfrac{Tg}{lcm(X,Y)}+1}{2}\right\rfloor$。否则，无解。

$p$ 的数量也就是 $t$ 的数量，也就是两个条件同时满足的情况数。减去即可。

[代码](/zhu/contests/NOIP-Camp-6-src/A.html)

## C

首先暴力模拟 $20$ 轮，把 `(type&1)==1` 的那些人死光。然后就不考虑它们了。

特判掉自己攻击力 $ATK=0$ 的情况。接下来考虑它不为 $0$ 的情况。把每个人的生命值，设置为它能活多少轮。也就是原来的生命值除以 $ATK$ 上取整。 

我们按人死去的轮数为主线，处理每一个事件

对于贡献，我们分成“整段”和“单点”。什么意思呢？

假设连续死了两个人，时间为 $t_1,t_2$。“整段”是说 $[t_1+1,t_2-1]$。这一段时间内，没有人死，贡献是恒定的。而 “单点” 时贡献可能发生改变。

我们用线段树维护每个人的攻击力。注意到现在人的攻击不会翻倍，因此受不受翻倍影响就没有区别了。把后面两类的增益合并起来，然后在线段树上全局加即可。但是线段树要维护死人，就是我们维护一下当前区间里有多少活人。然后更新和的之后乘的不是 $r-l+1$，而是活人个数。死人的时候做一个单点修改即可。

接下来算贡献。“整段” 的贡献直接算，然后乘一下就行。“单点” 的贡献需要考虑一下，因为可能会死人。还要讨论一个情况：如果上一轮死的人排在当前的后面，那它后面的人会依次贡献一波，然后转个头回到开始位置。而如果在当前的前面，直接过来就行。“转个头”会影响中间间隔的轮数，以及我们认为的“整段”大小。

然后处理一些小细节就行了。

[代码](/zhu/contests/NOIP-Camp-6-src/C.html)
